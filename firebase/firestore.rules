rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /{document=**} {
      allow read, write: if false;
    }

    function isCurrentUser(request, userId) {
      return request.auth != null && request.auth.uid == userId;
    }

    match /users/{userId} {
      allow read: if isCurrentUser(request, userId);
      allow create, update: if isCurrentUser(request, userId);

      // Allow recording the user's votes
      match /votes/{commentId} {
        allow read: if isCurrentUser(request, userId);
        allow write: if isCurrentUser(request, userId);
      }

      // Allow read for public fields for other users
      match /{public=**} {
        allow read: if request.auth != null;
      }

      // Only the backend should update the activity of the user
      // Other users can read the contents
      match /activity/{activityId} {
        allow write: if false;
        allow read: if request.auth != null;
      }

      // Only the backend should create a notification, the user is allowed to update it
      match /notifications/{notificationId} {
        allow update: if isCurrentUser(request, userId);
      }
    }


    function isCourseInstructor(request, courseId) {
      return request.auth != null && request.auth.uid in get(/databases/$(database)/documents/courses/$(courseId)).data.instructors;
    }
    // All the courses are public
    match /courses/{courseId} {
      allow read;

      // All the exercises are public when they are revealed
      match /exercises/{exerciseId=**} {
        allow read: if isCourseInstructor(request, courseId) || request.time > get(/databases/$(database)/documents/courses/$(courseId)).data.revealsAt;
      }

      match /progress/{userId} {
        allow read: if isCourseInstructor(request, courseId) || isCurrentUser(request, userId) || get(/databases/$(database)/documents/courses/$(courseId)).data.rankingVisibility == 'public';

        match /exerciseSolved/{level} {
          allow read: if isCourseInstructor(request, courseId) || isCurrentUser(request, userId);
        }
      }
    }
    match /{path=**}/exerciseScore/{level} {
      allow read: if isCurrentUser(request, resource.data.userId) || isCourseInstructor(request, resource.data.courseId) || get(/databases/$(database)/documents/courses/$(resource.data.courseId)).data.rankingVisibility == 'public';
    }
    match /{path=**}/exerciseUpsolveScore/{level} {
      allow read: if isCurrentUser(request, resource.data.userId) || isCourseInstructor(request, resource.data.courseId) || get(/databases/$(database)/documents/courses/$(resource.data.courseId)).data.rankingVisibility == 'public';
    }


    // The forum is available for authenticated users
    function isValidScore(score) {
      // TODO: find a better way of handling the switch from positive to negative votes
      return score == -2 || score == -1 || score == 0 || score == 1 || score == 2;
    }
    match /forum/{commentId} {
      allow read: if request.auth != null;
      allow create: if isCurrentUser(request, request.resource.data.userId) && request.resource.data.score == 1;
      allow update: if (isCurrentUser(request, request.resource.data.userId)
                        && request.resource.data.score == resource.data.score)
                       || (request.auth != null
                           && request.auth.uid != request.resource.data.userId
                           && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['score', 'replies'])
                           && isValidScore(math.abs(resource.data.score - request.resource.data.score)));
      allow delete: if isCurrentUser(request, get(/databases/$(database)/documents/forum/$(commentId)).data.userId);

      match /voters/{userId} {
        allow read: if isCurrentUser(request, userId);
        allow delete: if isCurrentUser(request, userId);
        allow create: if isCurrentUser(request, userId) && isValidScore(request.resource.data.vote);
        allow update: if isCurrentUser(request, userId) && isValidScore(request.resource.data.vote);
      }
    }



    // The user can read and add to their submissionQueue
    match /submissionQueue/{userId}/private/{submissionId} {
      allow read, create: if isCurrentUser(request, userId);
    }

    // Users can read their runs
    match /runs/{userId}/private/{runId} {
      allow read: if isCurrentUser(request, userId);
    }

    // All authenticated users can see the submission results
    match /submissions/{submissionId} {
      allow read: if request.auth != null;
    }
    // submission can have private fields available for only the current user and instructors
    function isInstructor(request, submissionId) {
      let course = get(/databases/$(database)/documents/submissions/$(submissionId)).data.course;
      return request.auth != null && request.auth.uid in get(course).data.instructors;
    }
    match /submissions/{submissionId}/private/{userId} {
      allow read: if isCurrentUser(request, userId) || isInstructor(request, submissionId);
    }


    // CodeDrafts
    match /codeDrafts/{courseId}/{exerciseId}/{userId} {
      allow read: if isCurrentUser(request, userId) || isCourseInstructor(request, resource.data.courseId);
      allow write: if isCurrentUser(request, userId);
    }
  }
}